{
  "hash": "7ce9f9cdf97ee6d3be0ed535483630f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Part 4: Making your script pretty.\"\nauthor: \"Poppy J Hesketh Best\"\ndate: \"2025-08-28\"\ncategories: [code, analysis, beginners, \"Anatomy of a BASH\", \"Guide\"]\nimage: \"profile.png\"\nexecute:\n  echo: true\n  eval: false\n  engine: knitr\n---\n\nHere we cover generating log files, and environment set up.\n\n**[Part 2]() ⋘ Part 3 ⋙ [Part 4]()**\n\n---\n\n## Making a pretty script!\n\nIn the long matrix stream of text that can be printed to you terminal, it is often useful to have important text stand out. This could be a missing file, non-existent paths, location of output file...\n\nAdding color to you script can be defined very easily. First you must indicate the color of the text needs to change using: `\\033[`. This open up all subsequent text to a color change, BUT no color has been defined yet. To define a color your must add the approporiate ANSI escape codes (Table 1). For red text you would define it as: `\\033[31m`. All text that follows this will be green. To revert the color back to default (typically white in a console), you need to close the escape code with a `\\033[m`.\n\n**Table 1.** ANSI color codes and their corresponding colors.\n\n| code | color  |\n|------|--------|\n| 31m  | red    |\n| 32m  | green  |\n| 36m  | cyan   |\n| 36m  | purple |\n| 34m  | blue   |\n| 33m  | orange |\n\nA complete example might look something like this (if you are printing text to the console using the command `echo`, then you also have to add `-e` to enable interpretation of backslash escapes):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho -e \"\\033[31m ERROR: something has gone very wrong because the text is all red!\\033[m\"\n```\n:::\n\n\nThis is quite a awkward to add and you can very easily miss a closure, and the the entirely of your console is colored red and you'll feel like you have made a terrible bloody mistake. A work around is to define the colors as a variables at the start of your script:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Define colors\ngreen='\\033[32m'; red='\\033[31m'; cyan='\\033[36m'; purple='\\033[35m'; nocolor='\\033[m'\n```\n:::\n\n\nThis alows you to change the text color as follows:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho -e \"${red}ERROR: something has gone very wrong because the text is all red!${nocolor}\"\n```\n:::\n\n\n### Adding a timestamp to the end of your script\n\nIf your optimising your scripts and trying to get an idea of run-time and computing resources its useful to print out the run time. This is easily done by first creating a timestamp at the  start and the end of your script, the  calculating the elapsed time, then printing the time.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/usr/bin/env bash\nstart_time=$(date +%s) # define start time\n\n#··············································#\n#··········· The rest of the script ···········#\n#··············································#\n\nfinish_time=$(date +%s) # define end time\n\n# Calculate the difference in seconds\nelapsed_time=$((finish_time - start_time))\n\n# Convert elapsed time to hours, minutes, and seconds\n((sec=elapsed_time%60, elapsed_time/=60, min=elapsed_time%60, hrs=elapsed_time/60))\ntimestamp=$(printf \"Total time taken - %d hours, %d minutes, and %d seconds.\" $hrs $min $sec)\necho $timestamp\n\n# Print the total runtime\necho -e \"\"\necho -e \"\"Total time taken: ${hrs}:${min}:${sec}\"\n\n```\n:::\n\n\nIf you are testing multiple computing resource allocation and different processing time, you might even consider printing a running table of your experiment along with your run parameters. For example, in the case of a a phylogeny script (`phylogeny`)\n\n::: {.cell}\n\n```{.bash .cell-code}\necho -e \"phylogeny.sh;${THREADS};${NBOOTSTRAPS};${NUMSEQUENCES};${hrs}:${min}:${sec}\" >> computing-time-test.csv\n```\n:::\n\n\n## `true`/`false` scenarios:\n\nPreviously the idea of having a true/false argument for dissabling the error correction of SPAdes, as an example. If you have included an argument for when `QCSPADes == true` and when `QCSPADes == false`.\n\nLike before we start the if statement with a scenario, which is `QCSPADes == true` (for when the -Q flag is uses), then we direct a specific action for that scenario, which is to performs SPADes using the assembly only features disabling the error correction. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\nif [[ QCSPADes == true ]]; then \n  spades.py -1 sample-1_R1.fastq.gz -2 sample-1_R2.fastq.gz -o sample-1_assembly-out --only-assembler\n···\n```\n:::\n\n\nThen we can continue the if statement to include an alternative scenario using an 'else if' (elif) statement, for for scenario when `QCSPADes == false`, to perform spades with default features. This is also the default functioning of the example script as we defined `Q)QCSPADes=false;;` at the start of the script.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n···\nelif [[ QCSPADes == false ]]; then\n  spades.py -1 sample-1_R1.fastq.gz -2 sample-1_R2.fastq.gz -o sample-1_assembly-out\nfi\n```\n:::\n\nThe entire if argument will look as follows:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nif [[ QCSPADes == true ]]; then \n  spades.py -1 sample-1_R1.fastq.gz -2 sample-1_R2.fastq.gz -o sample-1_assembly-out --only-assembler\nelif [[ QCSPADes == false ]]; then\n  spades.py -1 sample-1_R1.fastq.gz -2 sample-1_R2.fastq.gz -o sample-1_assembly-out\nfi\n```\n:::\n\n\n---\n\n**[Part 2]() ⋘ Part 3 ⋙ [Part 4]()**",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}