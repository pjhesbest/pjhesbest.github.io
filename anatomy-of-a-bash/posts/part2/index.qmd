---
title: "Part 2: Writing your script with a BANG!"
author: "Poppy J Hesketh Best"
date: "2025-08-24"
categories: [code, analysis, beginners, "Anatomy of a BASH", "Guide"]
image: "profile.png"
execute:
  echo: true
  eval: false
  engine: knitr
---

Here we cover creating help messages, defining arguments, and producing error messages.

**[Part 1]()** ⋘ Part 2 ⋙ **[Part 3]()**

# Starting your script with a bang

The the first line of a BASH script is called a *shebang*, and it specifies which interpreter/language will be used when executing the script. You might see a few different versions of this, and they can change the way your script operates.

- `#!/usr/bin/env bash` : This is **generally the safest choice in an HPC environment** if your script requires bash-specific features. Using env  ensures the bash interpreter is found via the environment's PATH, which can be modified by the module system. Useful in HPC environments, where modules may alter the available shell or software versions.
- `#!/bin/bash` : This assumes bash is located in /bin/bash, which is usually true for most Linux-based HPC systems. However, this can be less flexible if the HPC system has bash installed in non-standard locations or if you need different versions of bash.
- `#!/bin/sh` : If your script doesn’t require any bash-specific features and you just need a simple, lightweight script for tasks like job submission, basic file handling, or running commands.
- `#!/bin/sh -` : This is a more niche use case, and usually, you won’t need to run your HPC scripts in a login shell unless your environment setup is complex and isn't automatically inherited from your job scheduler.

## Printing a help message

A help message is just a chunk of text, and unlike in R and Python is actually detached from the argument definement (covered below). This means, that just because you write it in your help message, does not actually mean it is reflected in the defined arguments. Because of this, I prefer to have the help message written before writing the argument definition, as it helps remind me exactly what I need. For this you simply define a function called `Help()`, and open up the function with curly brackets `{`. The help message itself it just generated using `echo`. After the message is written, you close the function with another curly bracket `}`. The help message can be called simply by using the new command `Help`, in your script.

Position wise this should be placed before the argument definement, as one flag will to call the help function (`-h`), it needs to be defined before.

```{bash}
Help(){
    echo "Help message for the script: my script
        Required:
            -i      path to input file
            -o      path to output file
        Optional:
            -t      number of threads (default : 4)
            -h      print this help message and exit
}

# Now you can call the Help function
Help
```

## Defining arguments

One way to achieve a multi-sample functioning script very simply is to feed files into your script, rather than have the target file/values defined in the script. The most basic way to do this in BASH is to just add them to the end of you line of code:

```{sh}
# write the example script
echo "#!/usr/bin/env bash
eval "$(conda shell.bash hook)"
conda activate spades
spades.py -1 ${1} -2 ${2} -o ${3}
conda deactivate
" > assembly.sh

# This script could be run as follows
assembly.sh sample-1_R1.fastq.gz sample-1_R2.fastq.gz sample-1_assembly-out
```

Your inputs are defined sequentially, so the first file/value following `assembly.sh` becomes the variable `\${1}`, the second `\${2}`, so on. This is not the most user-friendly, and if you are going to be sharing scripts with colleagues it can be clunky for others. This is why its valuable to write script that have help mesages and defined flags. Using the same example as above, but this time there is a input flag for the required files (R1 and R2 reads), and an output directory:

```{sh}
assembly.sh -i sample-1_R1.fastq.gz -r sample-2_R1.fastq.gz -o sample-1_assembly-out
```

First, we need to define the arguments for the script, and this is achieved using the `while getopts a\:b:c:h option; do`. Which looks scarier than it actually is. This is utilising a `while` statement to search for input flags, before here as `i\:o:t:h`, which just means it will search for `-i`, `-o`, `-t`, and `-h`. Next those flags are defined into variables, for example the input flag it is defined as such: `i)input=${OPTARG};;`.

```{sh}
while getopts i:o:t:Q:h option
do 
    case "${option}" in 
        i)input=${OPTARG};;
        o)output=${OPTARG};;
        t)threads=${OPTARG};;
        Q)QCSPAdes=false;;
        h)Help; exit;;
    esac
done
```

Now for the rest of the script, whenever you call the variable `${input}`, the script will utilised whatever file/value was provided when the script was run (e.g. `-i path/to/contigs.fasta`). This is done for all the flags you need for your script to operate as intended while providing flexibility. The input doesnt need to be file paths, it can be values, chunks of text.

You can change this to have as many or as few arguments as you want. It is important to ensure that your help message (encoded in the function `Help` as described above), is as written to reflect the contents of the `while` argument. When the help message is called (e.g. `assembly.sh -h`), the script will terminate immediately after printing the help message, you acheive this by having the default bash function `exit` in `h)Help; exit;;`. 

A final feature you can take advatage of is utilising a `true`/`false` statement in the argument definement (e.g `Q)QCSPAdes=false;;`). For example, the assembler  SPAdes perform an optional read error correction by default, but if you perform error correction prior you may want to disable this with the SPAdes specific flag `--only-assembler`. In the example script the the flag `-Q` is added for when you want SPAdes to only perform the assembly, or omit the flag it in order to resort to the default setting, which in the example is false (i.e. perform/do not disable error correction). If you do this, you will later have to include an `if` statement in order to enact this in both a `true` and `false` scenario (this will be covered later).

## Producing error messages 

When you begin incorporating flags, its important that you set up some error messages to help people troubleshoot why the script might not be working for them. As by default, the error messages produced by BASH might not be the most informative to someone unfamiliar with the language.

Recall in the help message there where two types of input flags, required and optional. Lets go about creating error messages based on those two categories, starting with the required arguemnts. In a scenario where a user did not define a required arguments, we need to inform users what they have missed. We will do this with `if` statements.

```{sh}
if [[ -z ${inpput} ]]; then echo -e "ERROR: -i, input is missing"; Help, exit 1; fi
```
The logic of this `if`  statement, is in the situation where `-i` is not defined - the `-z` string - which means that the if statement is true if the string is empty (i.e. human language: `\${input}` does not exist/is empty because `-i` was not provided), then the following action is performed. That action is to print a message (`"ERROR: -i, input is missing"`), then call the `Help` function, which will print the help message to remind the user what the flags of the script are, then close the script with exit 1. If the statemet is not true (i.e human language: `\${input}` is not empty, before a input was provided), the `if` statement ends (`fi`, for finish), and the script continues. There are additional features to `if` statements that will be covered later, but they are very powerful tools to utilise in your script.

For optional argument, we don't need to colapse the script if no file or value was provide when the scrip was run, instead default value/path can be utilised. In the help message, we stated that the default number of threads was 4. So we set it as such using another `if` statement. 

```{sh}
if [[ -z "${threads}" ]]; then threads=4; fi
```

The same logic as before is applied, except this time we set the threads variable to the default value before ending the `if` statement (`threads=4; fi`). Now in the script, unless a `-t` value was given, whenever `${threads}` is called the default value will be used. You can even add more to this statement, to include a message to inform the user that the default value has been applied. 

Have a go and write the following `if` statements:

1. For the optional `-t` flag, add a message that the number of threads is the default value.
2. An error message for the scenario where `-o` has not been provided
3. Make the `-o` an optional flag and default the output directory to the current working directory

::: {.callout-tip collapse="true" title="Solution to 1"}

Since `${threads}` has a value, it is useful to use the variable instead of a hard number, as at some point in the future you might change the value of the default, and you want to have a script where you need to change that value in as few places as possible. In the present example, you would only have to change that value in two places: the `if` statement and the `Help` message.

```{sh}
if [[ -z "${threads}" ]]; then 
  threads=4; 
  echo "Number of threads not specified, utilising default value ${threads}
fi
```

:::

::: {.callout-tip collapse="true" title="Solution to 2"}

Simply need to add a echo to the if statement. This can be personalised hower you want as long as it is informative to the user.
```{sh}
if [[ -z ${output} ]]; then echo -e "ERROR: -o, output is missing"
  Help, exit 1
fi
```

:::


::: {.callout-tip collapse="true" title="Solution to 3"}

To define the output as the working directory you will need to use the function `$(pwd)`, which print the full path to the curren working directory. That is how we define the output. Same as in (1), we will use the variable `${output}` to report the output path.

```{sh}
if [[ -z ${output} ]]; then 
  output=$(pwd)
fi

# Print message to inform of the working directory
echo -e "Output path is missing, defaulting to current directory: ${output}"
```

:::



